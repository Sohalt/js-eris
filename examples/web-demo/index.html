<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Encoding for Robust Immutable Storage</title>
    <link rel="stylesheet" href="style.css">
    <script src="index.js"></script>
  </head>
  <body>
    <h1>Encoding for Robust Immutable Storage (ERIS)</h1>
    <div>

      <div id="notes">
        <p>This is a demo of ERIS - An Encoding for Robust Immutable Storage.</p>

        <p>ERIS encodes any content into uniformly sized (4kB) encrypted blocks. The original content can only be decoded with the read capability (an URN which contains the encryption key). </p>

      </div>

      <main>
        <div id="input">
          <h2>Input</h2>

          <textarea id="input-textarea"
                    placeholder="Enter some text and click Encode..."></textarea>

          <br> <br>

          <details>

            <summary>Sample Data</summary>

            <br>

            <button id="input-load-alice-in-wonderland">
              Load Alice in Wonderland
            </button>

            <h3>RDF</h3>
            <p>RDF data is normalized before it is encoded. This means that the same content always gets the same identifier (URN).</p><p>Load some sample RDF data, encode it and then decode it to see how the normalized form looks (it's not pretty).</p>

            <button id="input-load-sample-vocabulary">
              Load sample vocabulary
            </button>

            <button id="input-load-sample-actor">
              Load sample ActivityPub Actor (JSON-LD)
            </button>
          </details>

        </div>

        <div id="controls">
          <button id="controls-encode">Encode →</button>
          <details>
            <summary>input format</summary>
            <select id="controls-input-type" name="input-type" selected="plain-text">
              <option value="text/plain">plain text</option>
              <option value="text/turtle">RDF Turtle</option>
              <option value="application/ld+json">JSON-LD</option>
            </select>
          </details>
          <br>
          <button id="controls-decode">← Decode</button>
          <br>
          <br>
          <button id="controls-verify">Verify</button>

          <br>
          <pre id="controls-error"></pre>
          <pre id="controls-success"></pre>
        </div>

        <div id="encoded">
          <h2>Encoded</h2>

          <h3>Read capability</h3>
          <p>The read capability allows content to be read</p>
          <input id="encoded-eris-read-cap" type="url"></input>

          <h3>Verification capability</h3>
          <p>The verification capability allows all blocks to be verified for integrity, but does not allow the content to be read</p>
          <input id="encoded-eris-verification-cap" type="url"></input>

          <div id="blocks">
            <h3>Blocks</h3>
            <p>Blocks are stored in memory and can be removed or randomized (corrupted).</p>

            <details>
              <summary>IPFS</summary>
              <p>Optionally IPFS can be used as block storage and transport. Note: This does not work reliably from the browser. For more reliable demos of how to use ERIS with IPFS see the <a href="https://gitlab.com/openengiadina/data-model/">Guile</a> and <a href="https://gitlab.com/openengiadina/js-eris/-/tree/master/examples/ipfs">node.js</a> implementations/demos.</p>
              <input id="checkbox-enable-ipfs" type="checkbox">enable IPFS</input>
            </details>

            <div id="block-container">
            </div>
          </div>

        </div>

        <div class="break">
        </div>

      </main>

      <div id="about">
      <h2>About</h2>

      <p>ERIS is an encoding for content-addressing. The read capability which can be used to reference encoded content is exactly determined by the content itself (using a cryptographic hash).</p>

      <p>As the ERIS reference is an URI/URN, it can be referenced from usual web content. In particular, ERIS works very well with RDF (including JSON-LD).</p>

      <p>ERIS improves over naive content-addressing (just using the hash of the content as identifier):
        <ul>
          <li>Peers transporting and storing block without holding the read capability are not able to read the content.</li>
          <li>Blocks are uniformly sized and small. This allows corruption to be detected much faster, can be used to optimize storage and transport levels and incentivizes caching as caching an individual block is cheap (as compared to caching the entire content).</p>
          <li>Peers holding the verification capability can cache all the blocks required to decode the content without being able to read the content.</li>
        </ul>
      </p>

      <p>ERIS is developed as part of the <a href="https://openengiadina.net/">openEngiadina</a> project. We intend to use ERIS to implement an ActivityPub server enabling offline-first and decentralized applications.</p>

    For more information see:

      <ul>
        <li><a href="https://openengiadina.net/papers/eris.html">An Encoding for Robust Immutable Storage</a></li>
        <li><a href="https://openengiadina.net/papers/content-addressable-rdf.html">Content-addressable RDF</a></li>
        <li><a href="https://openengiadina.net/papers/rdf-signify.html">RDF Signify</a> (how to sign content-addressed RDF)</li>
      </ul>

      <p>This demo and the JavaScript (and Guile) implementations are free software. See the <a href="https://gitlab.com/openengiadina/js-eris">Git repository</a>.

      </div>

    </div>

  </body>
</html>
